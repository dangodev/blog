<!DOCTYPE html>
<html lang="en">
  <head>
    <title>the state of ES Modules in 2020</title>
    <link rel="stylesheet" href="/assets/app.min.css" />

    
    <meta charset="utf-8">
<meta name="description" content="The biggest change to JavaScript in years is a shockingly-quiet revolution" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0" />
<meta name="theme-color" content="#000" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta http-equiv="x-ua-compatible" content="IE=Edge" />
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml">
<link rel="alternate" type="application/json" title="JSON Feed 1.0" href="/feed.json">
<link rel="apple-touch-icon" href="/assets/images/drew-monogram-black.png" />
<link rel="icon" type="image/png" href="/assets/images/drew-monogram-black.png" />

  </head>
  <body>
    <div class="wrapper">
      <nav class="nav">
  <ol class="nav-list">
    <li>
      <a href="/">
        <h1 class="nav-title">
          <img class="nav-logo" src="/assets/images/drew-monogram-black.png" width="512" height="512" alt="Drew Powers" />
          <div class="nav-blog">blog</div>
        </h1>
      </a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="/">All</a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="/tag/design">design</a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="/tag/dev">dev</a>
    </li>
    <li class="nav-page">
      <a class="nav-link" href="/about">About</a>
    </li>
  </ol>
</nav>


      <header class="post-header">
        <h1 class="post-title">the state of ES Modules in 2020</h1>
        <p class="post-description">The biggest change to JavaScript in years is a shockingly-quiet revolution</p>
        <dl class="post-meta">
          <dt class="post-meta-key">published</dt><dd class="post-meta-value">2020-03-08</dd>
          
          <dt class="post-meta-key">updated</dt><dd class="post-meta-value">2020-03-10</dd>
          
          <dt class="post-meta-key">tagged</dt><dd class="post-meta-value"><a href="/tag/dev">dev</a></dd>
        </dl>
      </header>

      <main role="main" class="post-body post-body__the-state-of-es-modules-in-2020">
        <p>It‚Äôs 2020‚ÄîMarch to be exact‚ÄîES Modules (ESM) are now supported in both <a href="https://caniuse.com/#feat=es6-module">browsers</a> and
<a href="https://medium.com/@nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663">Node.js</a>. It‚Äôs a rather prolific change to JavaScript. So why aren‚Äôt more people talking
about it?</p>
<p>JavaScript going from no module system to <em>any</em> module system is pretty big deal, because modules
affect <em>nearly everything</em> about how you write code. Remember that as recently as 2016 we were still
<a href="https://auth0.com/blog/javascript-module-systems-showdown/">discussing CommonJS, AMD, UMD, and ESM alongside each other</a>. Going from no module
system to one is enough, but fragmenting between <strong>three</strong> before landing on a common <strong>fourth</strong> has
given us all whiplash. But now that the dust is settling, why aren‚Äôt we all sold on ESM?</p>
<h2>modules affect everything</h2>
<p>To expand a bit more on why module systems affect so much, let‚Äôs take an example of code in CommonJS
and see what it takes to upgrade to ESM:</p>
<pre><code class="language-js">if (process.env.NODE_ENV === 'development') {
  require('./dev-tools');
}
</code></pre>
<p>Here, CommonJS has let us conditionally load or not load a module. But if we try and switch to ESM:</p>
<pre><code class="language-js">if (process.env.NODE_ENV === 'development') {
  import './dev-tools'; // SyntaxError: import declarations may only appear at top level of a module
}
</code></pre>
<p>Uh oh. ESM demands all synchronous imports are in the top-level scope. So it‚Äôs not a 1:1 change. We
<em>could</em>, however, replace that with an async import:</p>
<pre><code class="language-js">if (process.env.NODE_ENV === 'development') {
  import('./dev-tools'); // this works‚Ä¶
}

// ‚Ä¶ but now code that follows won‚Äôt wait for this module to be loaded because it‚Äôs async
</code></pre>
<p>However this fundamentally changes how our program works. Whereas <code>require()</code> was synchronous, and
any code that followed was blocked until that module finished loading, <code>import()</code> will do no such
thing‚Äîit‚Äôs a promise that must be handled separately. So now you‚Äôll have to rewrite the rest of this
module to account for that.</p>
<p>Again, this just goes to show that changing a module system isn‚Äôt simple‚Äîif it was, then they
probably wouldn‚Äôt be two systems to begin with! <strong>Changing the module system is one of the biggest
changes you can make in a language</strong> because everything about application development changes with
it‚Äîthe modules themselves, logic within, and dependency chains.</p>
<h2>Why switch to ESM</h2>
<p>A common barrier to ESM is the sheer amount of CommonJS there is‚Äîvirtually the entire NodeJS
ecosystem is still stick in CommonJS. But switching to ESM yields several benefits:</p>
<ul>
<li>ESM is universal, meaning the same JavaScript works in a browser &amp; the server</li>
<li>Remote module imports‚Äîyou can load JavaScript <a href="https://www.pika.dev/cdn">using a CDN</a>! üéâ</li>
<li>No bundling needed</li>
<li>No transpilation needed (except for legacy browser support feature-by-feature)</li>
<li><a href="https://dev.to/pika/a-future-without-webpack-ago">Better caching</a> over traditional bundling</li>
</ul>
<h2>ESM is the future!</h2>
<p>So if module systems affect everything, down from the code we write to the JS-powered toolchains we
rely on, why do we continue to write new code that we all know now has an expiration date on it? In
case you‚Äôre not sure whether or not you‚Äôre writing ESM-ready code, if you‚Äòre using any of the
following, you‚Äôre likely not:</p>
<ul>
<li><strong>React:</strong> doesn‚Äôt ship an ESM-ready package (as of <a href="https://github.com/facebook/react/issues/11503">Mar 2020</a>)</li>
<li><strong>npm:</strong> <code>&lt; 8%</code> of npm packages <a href="https://www.pika.dev/about/stats">ship ESM</a> (as of <a href="https://www.pika.dev/about/stats">Oct 2019</a>)</li>
<li><strong>Node.js:</strong> though it supports ESM, it‚Äôs not in a stable LTS release yet (as of <a href="https://medium.com/@nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663">Nov
2019</a>)</li>
<li><strong>webpack</strong>: can‚Äôt ship your code as ESM (as of Mar 2020)</li>
</ul>
<p>By choosing these tools even in new projects, you‚Äôre shipping legacy code that already has a limited
lifespan. Be sure you understand the tradeoffs you‚Äôre making when doing so.</p>
<h2>How to make a difference</h2>
<p>There are lots of new and exciting projects that are leading the way toward shipping more ESM-ready
code to the web:</p>
<h3>Snowpack</h3>
<p><a href="https://www.snowpack.dev/">Snowpack</a> (a play on ‚Äùno pack‚Äù) is an install tool that lets you ship ESM-ready code
straight to the browser, without sacrificing npm. You can <code>npm install</code> like normal, and lets you
use Preact, Vue, Svelte, and more but with <strong>zero build time</strong> and <strong>no configuration.</strong></p>
<p><a href="https://www.snowpack.dev/">snowpack.dev</a></p>
<h3>Pika CDN</h3>
<p><a href="https://www.pika.dev/registry">Pika Registry</a> does all the work of finding ESM-ready packages for you. Search for
any keyword like you would on npm, except Pika Registry can tell you instantly whether or not that
package supports ESM.</p>
<p><a href="https://www.pika.dev/registry">pika.dev/registry</a></p>
<h3>Deno</h3>
<p><a href="https://deno.land/">Deno</a> is a new competitor to Node.js, built with V8, Rust, and Tokio and features native
TypeScript and ESM support out-of-the-box. Its guiding principle is to more closely mirror
ECMAScript in the areas where Node departed, principally only allowing ESM rather than CommonJS.
Though the project is in beta, it‚Äôs already gathering community attention and shows tons of promise.</p>
<p><a href="https://deno.land/">deno.land</a></p>
<p>To recap, the current state of ESM in 2020 is: <strong>it‚Äôs ready to use everywhere,</strong> but <strong>it‚Äôs up to
you to opt-in!</strong> Give some of the new ESM tools a try, and you might find yourself dealing with less
tooling, less configuration, and other great benefits while helping the community at large unify
around ESM.</p>

      </main>

      <footer class="footer">
  ¬© MMXX
  <br />
  <a href="/rss.xml">RSS</a> / <a href="/feed.json">JSON</a>
  <br />
  this website is encrypted and 100% analytics-free&nbsp;üñ§ if you want to support this blog,
  tweet or share&nbsp;a&nbsp;link!
  <br />
  built with <a href="https://cobalt-org.github.io/" rel="noopener noreferrer" target="_blank">Cobalt</a>
  (<a href="https://github.com/dangodev/blog" rel="noopener noreferrer" target="_blank">source</a>)
</footer>

    </div>
  </body>
</html>
